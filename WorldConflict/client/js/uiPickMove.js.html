<script>
var erisk = (function(my) {

    /**
     * This is the human "player controller".
     * It allows a human to picks moves using the UI, and calls reportMoveCallback
     * with a Command object describing the move once it is decided.
     */
    const uiState = {};

    my.uiPickMove = function(player, state, reportMoveCallback) {

        uiCallbacks.setRegionSelectedCB(function(region) {
            if (!appState.isInGame()) {
                return;
            }

            // Clear state if no region or we're in build mode
            if (!region || (state.moveDecision && state.moveDecision.type === 'build')) {
                setCleanState();
                return;
            }

            if (!state.moveDecision || typeof state.moveDecision.source === 'undefined') {
                // First region selection - check if valid source
                if (state.regionHasActiveArmy(player, region)) {
                    state.moveDecision = {
                        type: 'army-move',
                        source: region.index,
                        count: state.soldierCount(region),
                        highlitRegions: region.neighbors.concat(region.index)
                    };
                }
            } else if (state.moveDecision.type === 'army-move') {
                // Second region selection - create and execute command
                const command = new ArmyMoveCommand(
                    state,
                    player,
                    state.moveDecision.source,
                    region.index,
                    state.moveDecision.count
                );

                reportMoveCallback(command);
            } else {
                // Cancel move
                setCleanState();
            }

            erisk.gameRenderer.updateDisplay(state);
        });

        uiCallbacks.setTempleSelectedCB(function(region) {
            if (!appState.isInGame()) {
                return;
            }

            const temple = state.temples[region.index];
            const templeOwner = state.owner(temple.regionIndex);

            if (templeOwner && templeOwner.index === player.index) {
                state.moveDecision = {
                    type: 'build',
                    regionIndex: temple.regionIndex,
                    buttons: makeUpgradeButtons(temple)
                };
                erisk.gameRenderer.updateDisplay(state);
            } else {
                renderUtils.showFloatingText({
                    regionIdx: temple.regionIndex,
                    text: "You do not own this temple",
                    color: '#fff',
                    width: 7,
                });
            }
        });

        uiCallbacks.setSoldierSelectedCB(function(soldier) {
            // Find which region this soldier belongs to
            let soldierRegion = null;
            gameData.regions.forEach(function(region) {
                if (sequenceUtils.contains(state.soldiersAtRegion(region.index), soldier)) {
                    soldierRegion = region;
                }
            });
            if (soldierRegion) {
                uiCallbacks.regionSelected(soldierRegion);
            }
        });

        uiCallbacks.setBuildCB(function(which) {
            if (state.moveDecision && state.moveDecision.type === 'build') {
                // Build buttons (upgrades) handled here
                if (which >= CONSTS.NUM_UPGRADES) {
                    // "Done" button clicked
                    setCleanState();
                } else {
                    // Create BuildUpgradeCommand
                    const upgradeIndex = which + 1; // +1 because upgrades start at index 1
                    const command = new BuildUpgradeCommand(
                        state,
                        player,
                        state.moveDecision.regionIndex,
                        upgradeIndex
                    );

                    // Store UI state for soldier purchases
                    if (upgradeIndex === CONSTS.UPGRADES.SOLDIER.index) {
                        uiState[player.index] = gameData.regions[state.moveDecision.regionIndex];
                    }

                    reportMoveCallback(command);
                }
            } else {
                // Move action buttons (Cancel/End turn)
                if (which === 1) {
                    // End turn
                    const command = new EndMoveCommand(state, player);
                    endTurn(command);
                } else {
                    // Cancel move
                    setCleanState();
                }
            }
        });

        uiCallbacks.setUndoCB(() => {
            erisk.performUndo(state);
        });

        uiCallbacks.setResignCB(() => {
            const command = new ResignationCommand(state, player);
            reportMoveCallback(command);
        });

        setCleanState();

        if (gameData.numHumanPlayers() > 1 && gameData.humanTimeLimit != CONSTS.UNLIMITED_TIME) {
            erisk.startExpirationTimer(() => {
                const command = new EndMoveCommand(state, player);
                endTurn(command);
            });
        }

        if (uiState[player.index]) {
            uiCallbacks.templeSelected(uiState[player.index]);
            delete uiState[player.index];
        }

        function endTurn(command) {
            if (erisk.stopExpirationTimer) {
                erisk.stopExpirationTimer();
            }
            reportMoveCallback(command);
        }

        function setCleanState() {
            // Create proper move decision with action buttons
            state.moveDecision = {
                type: 'none',
                highlitRegions: gameData.regions
                    .filter(region => state.regionHasActiveArmy(player, region))
                    .map(r => r.index),
                buttons: [
                    { text: "Cancel" },
                    { text: "End turn" }
                ]
            };
            erisk.gameRenderer.updateDisplay(state);
        }

        function makeUpgradeButtons(temple) {
            const templeOwner = state.owner(temple.regionIndex);
            if (!templeOwner) {
                console.log("Could not find owner for temple with regionIndex = " + temple.regionIndex);
                return [];
            }

            const upgradeButtons = CONSTS.UPGRADES.slice(1).map(makeUpgradeButton);

            function makeUpgradeButton(upgrade) {
                const level = getCurrentUpgradeLevel(upgrade);
                const cost = upgrade.cost[level];
                const text = utils.template(upgrade.name, CONSTS.TEMPLE_LEVELS[level]) +
                    domUtils.elem('b', {}, " (" + cost + "&#9775;)");
                const description = utils.template(upgrade.desc, upgrade.level[level]);
                const curUpgrade = CONSTS.UPGRADES[temple.upgradeIndex];

                const hidden =
                    (upgrade === CONSTS.UPGRADES.REBUILD && !curUpgrade) ||
                    isInconsistentUpgrade(upgrade, curUpgrade) ||
                    level >= upgrade.cost.length ||
                    level < state.rawUpgradeLevel(templeOwner, upgrade) ||
                    templeOwner.index !== player.index;

                return {
                    text,
                    description,
                    disabled: cost > state.cashForPlayer(player),
                    hidden
                };

                function getCurrentUpgradeLevel(upgrade) {
                    if (temple.upgradeIndex === upgrade.index) {
                        return temple.level + 1;
                    } else if (upgrade === CONSTS.UPGRADES.SOLDIER) {
                        return state.numBoughtSoldiers || 0;
                    }
                    return 0;
                }

                function isInconsistentUpgrade(upgrade, currentUpgrade) {
                    return currentUpgrade &&
                           currentUpgrade !== upgrade &&
                           upgrade !== CONSTS.UPGRADES.SOLDIER &&
                           upgrade !== CONSTS.UPGRADES.REBUILD;
                }
            }

            upgradeButtons.push({text: "Done"});
            return upgradeButtons;
        }
    };

    return my;
}(erisk || {}));
</script>