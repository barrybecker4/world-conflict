<script>
var erisk = (function(my) {

    /**
     * This is the human "player controller".
     * It allows a human to picks moves using the UI, and calls reportMoveCallback
     * with an object describing the move once it is decided.
     * If the user takes too long, then "End turn" is called automatically.
     */
    const uiState = {};

    my.uiPickMove = function(player, state, reportMoveCallback) {

        uiCallbacks.setRegionSelectedCB(function(region) {
            if (!appState.isInGame()) {
                return;
            }
            if (!region || state.moveDecision.isBuildMove()) {
                setCleanState();
            }

            if (typeof state.moveDecision.source == 'undefined' && region) {
                // Create a potential army move command
                const potentialCommand = new ArmyMoveCommand(
                    state,
                    player,
                    region.index,
                    null, // destination not yet selected
                    state.soldierCount(region)
                );

                // Pre-validate source selection
                const validation = potentialCommand.validateSource();
                if (validation.valid) {
                    state.moveDecision = {
                        source: region.index,
                        count: state.soldierCount(region),
                        highlitRegions: region.neighbors.concat(region.index)
                    };
                }
            } else if (region) {
                const command = new ArmyMoveCommand(
                    state, player, state.moveDecision.source,
                    region.index, state.moveDecision.count
                );

                reportMoveCallback(command);
            }
            else {
                // some random region - cancel move
                setCleanState();
            }

            erisk.gameRenderer.updateDisplay(state);
        });

        uiCallbacks.setTempleSelectedCB(function(region) {
            if (!appState.isInGame()) {
                return;
            }
            const temple = state.temples[region.index];
            const templeOwner = state.owner(temple.regionIndex);
            if (templeOwner) {
                // Instead of creating a BuildMove, we prepare for BuildUpgradeCommand
                // But we don't create the command yet - we need to know which upgrade first
                state.moveDecision = {
                    type: 'build',
                    regionIndex: temple.regionIndex,
                    buttons: makeUpgradeButtons(temple),
                    // Store reference to player for command creation later
                    player: player
                };
                erisk.gameRenderer.updateDisplay(state);
            } else {
                renderUtils.showFloatingText({
                    regionIdx: temple.regionIndex,
                    text: "You do not own this temple",
                    color: '#fff',
                    width: 7,
                });
            }
        });

        uiCallbacks.setSoldierSelectedCB(function(soldier) {
            // delegate to the region click handler, after finding out which region it is
            let soldierRegion = null;
            gameData.regions.map(function(region) {
                if (sequenceUtils.contains(state.soldiersAtRegion(region.index), soldier))
                    soldierRegion = region;
            });
            if (soldierRegion)
                uiCallbacks.regionSelected(soldierRegion);
        });

        uiCallbacks.setBuildCB(function(which) {
            if (state.moveDecision && state.moveDecision.type === 'build') {
                // Build buttons (upgrades) handled here
                if (which >= CONSTS.NUM_UPGRADES) {
                    // "Done" button clicked - just clear state
                    setCleanState();
                } else {
                    // Create the BuildUpgradeCommand now that we know which upgrade
                    const upgradeIndex = which + 1; // +1 because upgrades start at index 1
                    const command = new BuildUpgradeCommand(
                        state,
                        player,
                        state.moveDecision.regionIndex,
                        upgradeIndex
                    );

                    // Validate before executing
                    const validation = command.validate();
                    if (!validation.valid) {
                        // Show validation errors
                        renderUtils.showFloatingText({
                            regionIdx: state.moveDecision.regionIndex,
                            text: validation.errors[0], // Show first error
                            color: '#f88',
                            width: 10,
                        });
                        return;
                    }

                    // Store UI state if it's a soldier purchase (for convenience)
                    if (upgradeIndex === CONSTS.UPGRADES.SOLDIER.index) {
                        uiState[player.index] = gameData.regions[state.moveDecision.regionIndex];
                    }

                    reportMoveCallback(command);
                }
            } else {
                // Move action buttons (Cancel/End turn) handled here
                if (which === 1) {
                    // End turn - create EndMoveCommand
                    const command = new EndMoveCommand(state, player);
                    endTurn(command);
                } else {
                    // Cancel move
                    setCleanState();
                }
            }
        });

        uiCallbacks.setUndoCB(() => {
            const result = erisk.getCommandProcessor().undo();
            if (result.success) {
                erisk.performUndo(result.newState);
            } else {
                renderUtils.showFloatingText({
                    regionIdx: state.activePlayer().homeRegion,
                    text: result.error,
                    color: '#f88',
                    width: 10,
                });
            }
        });

        uiCallbacks.setResignCB(() => reportMoveCallback(new ResignationCommand(state, player)));

        setCleanState();

        if (gameData.numHumanPlayers() > 1 && gameData.humanTimeLimit != CONSTS.UNLIMITED_TIME) {
            erisk.startExpirationTimer(endTurn);
        }

        if (uiState[player.index]) {
            uiCallbacks.templeSelected(uiState[player.index]);
            delete uiState[player.index];
        }

        function endTurn(command) {
            uiCallbacks.moveEndTasks();
            reportMoveCallback(command);
        }

        function setCleanState() {
            state.moveDecision = new Move();
            state.moveDecision.highlitRegions =
                gameData.regions.filter(region => state.regionHasActiveArmy(player, region)).map((r) => r.index);
            erisk.gameRenderer.updateDisplay(state);
        }

        function makeUpgradeButtons(temple) {
            const templeOwner = state.owner(temple.regionIndex);
            if (!templeOwner) {
                console.log("Could not find owner for temple with regionIndex = " + temple.regionIndex);
                return;
            }

            const upgradeButtons = CONSTS.UPGRADES.slice(1).map(makeUpgradeButton);

            function makeUpgradeButton(upgrade) {
                // current upgrade level (either the level of the temple or number of soldiers bought already)
                const level = getCurrentUpgradeLevel(temple);

                const cost = upgrade.cost[level];
                const text = utils.template(upgrade.name, CONSTS.TEMPLE_LEVELS[level]) +
                    domUtils.elem('b', {}, " (" + cost + "&#9775;)");
                const description = utils.template(upgrade.desc, upgrade.level[level]);
                let curUpgrade = CONSTS.UPGRADES[temple.upgradeIndex];

                const hidden =
                    (upgrade === CONSTS.UPGRADES.REBUILD && !curUpgrade) // rebuild only available if temple is upgraded
                    || isInconsistentUpgrade()
                    || level >= upgrade.cost.length // highest level reached
                    || level < state.rawUpgradeLevel(templeOwner, upgrade) // another temple has this upgrade already
                    || templeOwner.index != player.index; // we're looking at an opponent's temple

                return { text, description, disabled: cost > state.cashForPlayer(player), hidden };

                function getCurrentUpgradeLevel(temple) {
                    return (temple.upgradeIndex === upgrade.index) ?
                        temple.level + 1 : ((upgrade === CONSTS.UPGRADES.SOLDIER) ? (state.numBoughtSoldiers || 0) : 0);
                }

                // Check if the temple is already upgraded with a different upgrade
                function isInconsistentUpgrade() {
                    return curUpgrade && curUpgrade !== upgrade &&
                        upgrade !== CONSTS.UPGRADES.SOLDIER &&
                        upgrade !== CONSTS.UPGRADES.REBUILD;
                }
            }

            upgradeButtons.push({text: "Done"});
            return upgradeButtons;
        }
    }

    return my;
}(erisk || {}));
</script>