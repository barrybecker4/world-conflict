<script>
var erisk = (function(my) {
    const { $, div } = domUtils;
    const POLL_DELAY = 2000;

    my.runSetupScreen = function() {
        audio.setupAudio();
        appState.setInSetup();
        let configuringPlayer = null;

        retrieveAndShowOpenGames();

        /**
         * Called after a user enters (sits down at) an existing or new game.
         * Either the game will now start, or will will continue waiting for other players to join.
         */
        const gameEnteredCallback = function(status) {
            erisk.setOpenGamesScreenVisibility(false);
            console.log("game entered. status = " + status);
            switch (status) {
                case CONSTS.WAITING_FOR_PLAYERS:
                    erisk.createSetupUI();
                    doneConfiguring();
                    break;
                case CONSTS.READY_TO_START:
                    startGame();
                    break;
                default: // do nothing;
            }
        }

        function showNewGameSetup() {
            appState.setInSetup();
            regenerateGameDataWithNewMap(gameEnteredCallback);
            erisk.createSetupUI();

            // callback for the buttons on the bottom
            uiCallbacks.setBuildCB(function(whichButton) {
                if (!storage.isSetupValid()) return;

                switch (whichButton) {
                    case 0: // change map
                        regenerateGameDataWithNewMap();
                        break;
                    case 1: // done configuring
                        configuringPlayer = domUtils.userid();
                        // gameData.regions will be there after the map has been drawn
                        if (gameData.regions) {
                            persistGameData(() => {
                                if (areOpenSlots()) {
                                    doneConfiguring();
                                } else {
                                    startGame();
                                }
                            });
                        }
                        break;
                    default: throw new Error("Invalid button: " + whichButton);
                }
            });
        }

        function persistGameData(callback) {
           google.script.run
               .withSuccessHandler(gameId => {
                   gameData.gameId = gameId;
                   gameData.initialGameState.gameId = gameId;
                   if (callback) {
                       callback();
                   }
                })
               .withFailureHandler(showError)
               .persistGameData('unused', gameData.getSimpleObject());
        }

        function areOpenSlots() {
            const reducer = (accumulator, currentValue) =>
                accumulator + (currentValue === CONSTS.PLAYER_HUMAN_OPEN ? 1 : 0);
            const numOpen = storage.gameSetup.playerTypes.reduce(reducer, 0);
            return numOpen > 0;
        }

        /**
         * After clicking "done configuring", wait for other players to join.
         * If you are the owner and get tired of waiting, you can click "Start anyway" and unassigned players will be AIs.
         * configuration will not be editable while waiting for players to join.
         *
         * Players may also leave and go back to the open games screen up until
         * the time when all players are seated and the game starts.
         */
        function doneConfiguring() {
            appState.setWaitingForPlayersToJoin();
            erisk.updatePlayerConfigButtons();
            console.log("In doneConfiguring");

            // only the configuring player (owner) can decide to start before all players have joined
            const userid = domUtils.userid();
            const isConfiguringPlayer = configuringPlayer === userid;
            updateStartAnywayButton(isConfiguringPlayer);
            uiCallbacks.setBuildCB(function(whichButton) {
                switch (whichButton) {
                    case 0: // start anyway (before all slots filled)
                        startGameAfterConvertingOpenSlots();
                        break;
                    case 1: // leave this game table
                        console.log("Leaving!");
                        appState.setInSetup();
                        google.script.run
                            .withSuccessHandler(() => {
                                console.log("Player " + userid + " left the table");
                                retrieveAndShowOpenGames();
                            })
                            .withFailureHandler(showError)
                            .unseatPlayerFromOpenGame(domUtils.userid(), gameData.gameId);
                        break;
                    default: throw new Error("Invalid button: " + whichButton);
                }
            });

            pollForNewPlayers();
        }

        function updateStartAnywayButton(enabled) {
            const tip = enabled ?
                'If you are tired of waiting for other human players to join, ' +
                'you can click this and AI players will be used instead'
                : 'Only the player that configured the game can decide to start before all players have joined';

            erisk.gameRenderer.updateButtons([
                { text: 'Start anyway', disabled: !enabled, tip },
                { text: 'Leave', disabled: false, tip: 'Click to go back to open games' },
            ], "Waiting for players to join open slots...");
        }

        // poll for updates to the configuration - which will happen if another player joins this game
        function pollForNewPlayers() {
            if (!appState.isWaitingForPlayersToJoin())
                return;
            google.script.run
                .withSuccessHandler(function(newGameData) {
                    if (newGameData) { // we only get newGameData if players are different
                        gameData.initializeFrom(newGameData);

                        // These lines needed to update regions
                        erisk.gameRenderer.showMap($('map'), gameData.initialGameState);
                        erisk.gameRenderer.updateMapDisplay(gameData.initialGameState);

                        console.log("A new player joined this game. new status = " + newGameData.status);
                        gameEnteredCallback(newGameData.status);
                    } else {
                        // keep calling recursively until all players have joined, or player gets tired of waiting
                        setTimeout(pollForNewPlayers, POLL_DELAY);
                    }
                 })
                .withFailureHandler(showError)
                .getGameData(gameData.gameId, gameData.players);
        }

        function startGameAfterConvertingOpenSlots() {
            convertOpenSlotsToAiPlayersIfNeeded(startGame);
        }

        function regenerateGameDataWithNewMap(callback) {
            generateGameData(callback, false);
        }

        function regenerateGameDataWithoutNewMap(callback) {
            generateGameData(callback, true);
        }

        function generateGameData(callback, keepCurrentMap) {
            if (appState.isWaitingForPlayersToJoin() || appState.isInGameOrWaiting() || !storage.isSetupValid() )
                return;

            console.log(`Calling makeNewGameData - which will unseat ${domUtils.userid()}.`);
            google.script.run
                .withSuccessHandler(function(newGameData) {
                    gameData.initializeFrom(newGameData);
                    erisk.gameRenderer.showMap($('map'), gameData.initialGameState);
                    erisk.gameRenderer.updateMapDisplay(gameData.initialGameState);
                    if (callback) {
                        callback(newGameData.status);
                    }
                 })
                .withFailureHandler(showError)
                .makeNewGameData(storage.gameSetup, keepCurrentMap ? gameData.getSimpleObject() : null);
        }

        function retrieveAndShowOpenGames() {
            appState.setInOpenGamesDialog();
            retrieveAndShowOpenGamesPolling();
        }

        /**
         * Get all open games from server. There are 2 cases:
         * - There are one or more open games. In this case, allow the user to select one or create a new one.
         * - No open games. Go straight to the game setup screen to create a new one.
         * The method recursively calls itself to update the list of open games.
         */
        function retrieveAndShowOpenGamesPolling() {
            console.log("appState = " + appState.getCurrentState());
            if (!appState.isInOpenGamesDialog() || !storage.isSetupValid())
                return;

            google.script.run
                .withSuccessHandler(function(openGames) {
                    console.log("num openGames = " + openGames.length + " appState = " + appState.getCurrentState());
                    if (!appState.isInOpenGamesDialog()) {
                        // intentionally do nothing. Waiting for players to join.
                    }
                    else if (openGames.length === 0) {
                        showNewGameSetup();
                    }
                    else {
                        // show the gameTableSelection UI
                        erisk.openGamesScreen(
                            openGames,
                            () => { showNewGameSetup(); }, // if new game button clicked
                            gameEnteredCallback // if seat selected
                        );
                        // keep calling recursively until the player selects a spot
                        setTimeout(retrieveAndShowOpenGamesPolling, POLL_DELAY);
                    }
                 })
                .withFailureHandler(showError)
                .retrieveOpenGames();
        }

        function startGame() {
            erisk.prepareInGameUI();
            erisk.gameRenderer.updateDisplay(gameData.initialGameState);
            appState.setInGame();
            const state = gameData.initialGameState;
            erisk.gameRenderer.showPlayerBanner(state.activePlayer());
            erisk.playOneMove(state, false, configuringPlayer);
        }

        // Convert any unassigned open human slots to AI players to allow the game to start.
        function convertOpenSlotsToAiPlayersIfNeeded(callback) {
            const hasOpenSlots = gameData.players.some(player => player.type === CONSTS.PLAYER_HUMAN_OPEN);
            if (hasOpenSlots) {
                convertOpenSlotsToAiPlayers(() => {
                    erisk.updatePlayerConfigButtons();
                    persistGameData(callback);
                });
            }
            else callback();
        }

        function convertOpenSlotsToAiPlayers(callback) {
            for (let i = 0; i < gameData.players.length; i++) {
                const player = gameData.players[i];
                console.log("player.type = " + player.type + " player.name = " + player.name);
                if (player.type === CONSTS.PLAYER_HUMAN_OPEN && !player.name) {
                    storage.gameSetup.playerTypes[player.originalIndex] = CONSTS.PLAYER_AI;
                }
            }
            appState.setInSetup();
            regenerateGameDataWithoutNewMap(callback);
        }

        // Callback for player setup buttons. Assigns one of the player types.
        uiCallbacks.setSetupPlayerButtonsCB(function(event) {
            // set the player type for the player
            storage.gameSetup.playerTypes[event.playerIndex] = CONSTS.PLAYER_TYPES[event.playerTypeIndex];

            erisk.updatePlayerConfigButtons();
            erisk.updateConfigBottomButtons();
            regenerateGameDataWithoutNewMap();
        });

        // callback for AI level buttons
        uiCallbacks.setSetupAiLevelCB(function(aiLevel) {
            storage.gameSetup.aiLevel = aiLevel;
            erisk.updatePlayerConfigButtons();
            regenerateGameDataWithoutNewMap();
        });

        // callback for number of turns buttons
        uiCallbacks.setSetupTurnCountCB(function(turnCount) {
            storage.gameSetup.turnCount = turnCount;
            erisk.updatePlayerConfigButtons();
            regenerateGameDataWithoutNewMap();
        });

        // callback for time limit buttons
        uiCallbacks.setSetupTimeLimitCB(function(timeLimit) {
            storage.gameSetup.humanTimeLimit = timeLimit;
            erisk.updatePlayerConfigButtons();
            regenerateGameDataWithoutNewMap();
        });

        // callback for map size buttons
        uiCallbacks.setSetupMapSizeCB(function(mapSize) {
            storage.gameSetup.mapSize = mapSize;
            erisk.updatePlayerConfigButtons();
            regenerateGameDataWithoutNewMap();
        });
    }

    return my;
}(erisk || {}));
</script>
