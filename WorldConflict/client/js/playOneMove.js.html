<script>
var erisk = (function(my) {
    const SERVER_REQUEST_DELAY = 2000;
    const synchronizationState = {
        localHumanMoves: [],
        firstTime: true,
        requestStartTime: null,
        syncInProgress: false
    };

    /**
     * Deals with responding to user actions - whether human or AI.
     * This is the core game play logic. Runs on the client.
     */
    my.playOneMove = function(state, afterUndo, configuringPlayer) {
        if (!appState.isInGameOrWaiting() )
            return; // game terminated

        erisk.oneAtaTime(CONSTS.MOVE_DELAY, function() {
            const player = state.activePlayer();

            if (player.name === domUtils.userid()) {
                handleHumanPlayerTurn(player, state, afterUndo);
            }
            else { // AI or other human players
                erisk.setPreviousState(null); // only humans can undo

                // Only the configuring player should initiate AI moves on first turn
                const suppressAi = synchronizationState.firstTime && player.personality &&
                     (player.index === 0) && (configuringPlayer !== domUtils.userid());
                persistMovesAndPoll(state, suppressAi);
            }
            synchronizationState.firstTime = false;
            erisk.gameRenderer.updateDisplay(state);
        });
    };

    /**
     * This stores the player's move(s) in localHumanMoves, since, because of undo,
     * it's not final until "end move" is clicked.
     */
    function handleHumanPlayerTurn(player, state, afterUndo) {
        if (!appState.isInGame()) {
            appState.setInGame();
        }
        domUtils.show('resign');

        function moveCompletedCallback(move) {
            const newState = erisk.makeMove(state, move);
            move.stateId = newState.id;
            move.gameId = newState.gameId;
            if (afterUndo) {
                synchronizationState.localHumanMoves.pop();
            }
            synchronizationState.localHumanMoves.push(move);

            if (newState.endResult) { // did the game end?
                showEndGame(newState);
            } else {
                // Save state for potential undo
                erisk.setPreviousState(new GameState(state));
                // Using setTimeout to avoid stack overflow with recursive calls
                setTimeout(() => my.playOneMove(newState), 0);
            }
        }
        erisk.uiPickMove(player, state, moveCompletedCallback);
    }

    /**
     * Sends pending moves to server and starts polling for other player moves
     */
    function persistMovesAndPoll(state, suppressAi) {
        if (!appState.isWaitingForPlayersToMove())
            appState.setWaitingForPlayersToMove();

        if (synchronizationState.syncInProgress)
            return; // Don't allow multiple simultaneous server requests

        synchronizationState.syncInProgress = true;

        console.log(`[SYNC] persistMovesAndPoll: Sending ${synchronizationState.localHumanMoves.length} local moves. stateId: ${state.id}, activePlayerIndex: ${state.playerIndex}, localMoves: ${JSON.stringify(synchronizationState.localHumanMoves)}`);
        google.script.run
            .withSuccessHandler(() => {
                synchronizationState.localHumanMoves = []; // Reset local moves since they've been sent
                synchronizationState.syncInProgress = false;
                setTimeout(() => pollForMoves(state), CONSTS.MOVE_DELAY);
            })
            .withFailureHandler(error => {
                showError(error);
                synchronizationState.syncInProgress = false;
                setTimeout(() => persistMovesAndPoll(state, suppressAi), SERVER_REQUEST_DELAY);
            })
            .persistLocalMovesIfAnyAndPlayAi(
                synchronizationState.localHumanMoves,
                [state],
                gameData.getSimpleObject(),
                suppressAi
            );
    }

    /**
     * Poll server for moves by other players
     */
    function pollForMoves(state) {
        if (state.endResult)
            return;  // Stop polling if game is over

        // Start tracking time for timeout detection
        if (synchronizationState.requestStartTime == null) {
            synchronizationState.requestStartTime = new Date();
        }
        if (!appState.isWaitingForPlayersToMove()) {
            appState.setWaitingForPlayersToMove();
        }

        google.script.run
            .withSuccessHandler(handleServerResponse(state))
            .withFailureHandler(error => {
                showError(error);
                setTimeout(() => pollForMoves(state), SERVER_REQUEST_DELAY); // try to recover
            })
            .getGameMoves(state.gameId, state.id);
    }

    /**
     * Handle server response with moves from other players
     */
    function handleServerResponse(startState) {
        return async function(moves) {
            console.log(`[SYNC] handleServerResponse: Received ${moves.length} moves from server. startStateId: ${startState.id}, startStatePlayerIndex: ${startState.playerIndex}, moves: ${JSON.stringify(moves)}`);
            // First check if we need to handle a player timeout
            let currentState = checkForPlayerTimeout(startState, moves);

            // If we detected a timeout, the state will be different
            if (currentState !== startState) {
                // Start a new polling cycle with the updated state
                console.log(`[SYNC] handleServerResponse: Player timeout processed locally, re-polling. currentStateId: ${currentState.id}, activePlayerIndex: ${currentState.playerIndex}`);
                setTimeout(() => pollForMoves(currentState), 0);
                return;
            }

            if (moves.length > 0) { // Apply all moves received from server
                currentState = await replayServerMoves(currentState, moves);
            }

            if (currentState.endResult) { // game over
                showEndGame(currentState);
            }
            else if (currentState.activePlayer().getName() !== domUtils.userid()) {
                // Still not our turn, continue polling for other moves
                console.log(`[SYNC] handleServerResponse: Not our turn. Polling again. currentStateId: ${currentState.id}, newActivePlayerIndex: ${currentState.playerIndex}`);
                setTimeout(() => pollForMoves(currentState), SERVER_REQUEST_DELAY);
            }
            else { // It's our turn now!
                console.log(`[SYNC] handleServerResponse: Now our turn. Calling playOneMove. currentStateId: ${currentState.id}, activePlayerIndex: ${currentState.playerIndex}`);
                setTimeout(() => my.playOneMove(currentState), 0);
            }
        };
    }

    /**
     * Checks if a player has timed out and handles ot appropriately.
     * @return {GameState} Either original state or new state after timeout
     */
    function checkForPlayerTimeout(state, moves) {
        // Consider adding this only if verbose logging is desired, as it can be frequent.
        // console.log(`[SYNC] checkForPlayerTimeout: Checking for timeout. Current activePlayer: ${state.activePlayer().getName()} (index ${state.playerIndex}). Client: ${domUtils.userid()}. StateId: ${state.id}`);
        // If we received moves, reset timeout tracking
        if (moves.length > 0) {
            synchronizationState.requestStartTime = null;
            return state;
        }

        // Get information about the current player
        const nextPlayer = state.activePlayer();
        if (!nextPlayer) {
            throw new Error("nextPlayer unexpectedly " + nextPlayer +
                            ".\n startState=\n" + JSON.stringify(startState));
        }

        // Get information about the next human player (if any)
        const next = state.getHumanPlayerAfter(nextPlayer);

        // Only the next human player should handle timeouts
        if (!next || domUtils.userid() != next.humanPlayer.name) {
            return state;
        }

        // Calculate how long we've been waiting
        const elapsedTimeSinceRequest = new Date() - synchronizationState.requestStartTime;
        const timeoutThreshold = calculateTimeoutThreshold(next.numSkippedAIs);

        console.log(`Waiting for ${nextPlayer.getName()} for ${elapsedTimeSinceRequest/1000}s. ` +
                    `Timeout threshold: ${timeoutThreshold/1000}s`);

        // Check if player has exceeded time limit
        if (elapsedTimeSinceRequest > timeoutThreshold) {
            console.log(`[SYNC] checkForPlayerTimeout: Player ${nextPlayer.getName()} (index ${nextPlayer.index}) TIMED OUT. Initiator: ${domUtils.userid()}. stateId: ${state.id}, activePlayerIndex: ${state.playerIndex}. Sending ResignationMove.`);
            console.log(`Player ${nextPlayer.getName()} has timed out and will be eliminated. Sending resignation to server.`);
            synchronizationState.requestStartTime = null; // Reset to prevent re-timeout

            const resignationMove = new ResignationMove();
            // Properties like stateId and gameId for the move object itself are not standard
            // and should be handled when erisk.makeMove is called upon receiving from server.

            synchronizationState.localHumanMoves = [resignationMove];
            // Send the resignation using the current state; the server will process it,
            // and all clients (including this one) will update their state when they receive the processed move.
            persistMovesAndPoll(state, false); 

            // Return the original state. The game state will be updated when this client
            // receives the resignation move back from the server via the polling mechanism.
            return state; 
        }

        return state;
    }

    function calculateTimeoutThreshold(numSkippedAIs) {
        const humanTimeLimit = gameData.humanTimeLimit * 1000 + 3000; // Add buffer
        const aiTurnDelay = (numSkippedAIs || 0) * 6000; // 6 seconds per AI
        return humanTimeLimit + aiTurnDelay;
    }

    /**
     * Replay moves received from server with animations
     * @return {Promise<GameState>} Final state after applying all moves
     */
    async function replayServerMoves(state, moves) {
        let currentState = state;

        for (let i = 0; i < moves.length; i++) {
            const moveData = moves[i];
            const move = Move.reconstitute(moveData);

            if (CONSTS.DEBUG) {
                console.log(`${i+1}/${moves.length}) Applying move from server: ${JSON.stringify(move)}`);
            }

            console.log(`[SYNC] replayServerMoves: Processing move ${i+1}/${moves.length}. moveData: ${JSON.stringify(moveData)}. Pre-makeMove stateId: ${currentState.id}, activePlayerIndex: ${currentState.playerIndex}`);
            const nextState = erisk.makeMove(currentState, move);
            console.log(`[SYNC] replayServerMoves: Post-makeMove. nextStateId: ${nextState.id}, newActivePlayerIndex: ${nextState.playerIndex}`);


            await new Promise(resolve => {
                erisk.oneAtaTime(CONSTS.PLAYBACK_DELAY, () => {
                    audio.playSound(CONSTS.SOUNDS.CLICK);
                    erisk.gameRenderer.updateDisplay(nextState);
                    resolve();
                });
            });

            currentState = nextState;
        }

        return currentState;
    }

    /**
     * Shows end game UI and handles game completion
     */
    function showEndGame(state) {
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, () => erisk.gameRenderer.updateDisplay(state));
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, () => {
            const winner = state.endResult;
            const delay = 200;
            const duration = 4000;

            // Show appropriate victory banner
            if (winner !== CONSTS.DRAWN_GAME) {
                erisk.gameRenderer.showBanner(
                    winner.colorEnd,
                    `${winner.getName()} wins the game!`,
                    delay, duration
                );
            } else {
                erisk.gameRenderer.showBanner(
                    '#333',
                    "The game ends in a draw!",
                    delay, duration
                );
            }

            // Update UI for game over state
            erisk.gameRenderer.updateDisplay(state);
            $('turn-count').innerHTML = "Game over";

            const infoEl = $('info');
            infoEl.innerHTML = domUtils.elem('p', {}, "Click the button below to start a new game.");
            infoEl.style.background = '#555';

            domUtils.hide('move-info');
            erisk.gameRenderer.updateButtons([{text: "New game"}]);

            // Send final state to server
            persistMovesAndPoll(state, true);

            // Set up callback for new game button
            uiCallbacks.setBuildCB(erisk.runSetupScreen);
        });
    }
    
    return my;
}(erisk || {}));
</script>
