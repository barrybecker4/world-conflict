<script>
var erisk = (function(my) {
    const $ = domUtils.$;
    const SERVER_REQUEST_DELAY = 2000;
    const HUMAN_EXPIRATION_DELAY = 3 * SERVER_REQUEST_DELAY;
    const AI_TURN_DELAY = 6000;
    let localHumanMoves = [];
    let firstTime = true;
    let requestStartTime = null;

    /** Deals with responding to user actions - whether human or AI. */
    my.playOneMove = function(state, afterUndo, configuringPlayer) {
        if (!appState.isInGameOrWaiting() )
            return; // game terminated

        erisk.oneAtaTime(CONSTS.MOVE_DELAY, function() {

            const player = state.activePlayer();

            if (player.name === domUtils.userid()) {
                getMoveForCurrentPlayer(player, state, afterUndo);
            }
            else {
                erisk.setPreviousState(null); // only humans can undo
                // Don't run the AI if AI is first and this is not the configuring player
                const suppressAi = firstTime && player.personality && configuringPlayer != domUtils.userid();
                persistLocalMovesIfAnyAndPlayAi(state, suppressAi);
            }
            firstTime = false;
            erisk.gameRenderer.updateDisplay(state);
        });
    }

    /** This just stores the players move(s) in localHumanMoves since, because of undo,
     * it's not final until "end move" is clicked.
     */
    function getMoveForCurrentPlayer(player, state, afterUndo) {
        appState.setInGame();

        erisk.uiPickMove(player, state, function(move) {
            const newState = erisk.makeMove(state, move);
            move.stateId = newState.id;
            move.gameId = newState.gameId;
            if (afterUndo) {
                localHumanMoves.pop();
            }
            localHumanMoves.push(move);

            if (newState.endResult) { // did the game end?
                showEndGame(newState);
            } else {
                erisk.setPreviousState(new GameState(state)); // only humans can undo
                setTimeout(() => my.playOneMove(newState), 0); // recursive call
            }
        });
    }

    // Add this player's moves (if any) then AIs, then poll for all other players until our turn again.
    function persistLocalMovesIfAnyAndPlayAi(state, suppressAi) {
        appState.setWaitingForPlayersToMove();
        google.script.run
            .withFailureHandler(showError)
            .persistLocalMovesIfAnyAndPlayAi(localHumanMoves, [state], gameData.getSimpleObject(), suppressAi);
        localHumanMoves = [];
        setTimeout(() => replayMovesFromServer(state), SERVER_REQUEST_DELAY);
    }

    /**
     * Get all the moves since the specified state and replay them on this client until it is our move again.
     * If a player has left the game (say by closing the browser, not by time expiry) then they should be eliminated.
     * This is preferable to waiting forever for them to move.
     */
    function replayMovesFromServer(state) {
        if (!state.endResult) {
            if (requestStartTime == null) {
                requestStartTime = new Date();
            }
            appState.setWaitingForPlayersToMove(); // don't allow clicking when moves being replayed

            if (CONSTS.DEBUG) {
                console.log("Requesting replay moves from server starting at state.id = " + state.id);
            }

            google.script.run
                .withSuccessHandler(getPlaybackHandler(state))
                .withFailureHandler(showError)
                .getGameMoves(state.gameId, state.id);
        }
    }

    function getPlaybackHandler(startState) {

        /* @param moves - the moves that have been played since we last checked */
        return async function(moves) {

            continueIfNextPlayerLeftGame(startState, moves);
            const finalState = await replayMove(0, startState);

            async function replayMove(i, state) {
                if (i >= moves.length) {
                    return state;
                }
                const theMove = moves[i];
                const move = Move.reconstitute(theMove);
                let nextState = erisk.makeMove(state, move);
                if (CONSTS.DEBUG) {
                    console.log("   applying move with stateId: " + theMove.stateId + " to " +
                        state.id + " to give " + nextState.id + "(for " + state.activePlayer().getName() + ")");
                }

                erisk.oneAtaTime(CONSTS.PLAYBACK_DELAY, () => {
                    if (CONSTS.DEBUG) {
                        const name = state.activePlayer().getName();
                        console.log(`${i}) Move found on server for ${name}: ${JSON.stringify(move)}`);
                    }
                    audio.playSound(CONSTS.SOUNDS.CLICK);
                    erisk.gameRenderer.updateDisplay(nextState);
                });
                return await replayMove(i + 1, nextState);
            }

            if (finalState.endResult) {
                showEndGame(finalState);
            }
            else {
                if (finalState.activePlayer().name !== domUtils.userid()) {
                    if (CONSTS.DEBUG) {
                        console.log("activePlayer " + finalState.activePlayer().name +
                            " is not " + domUtils.userid() + " so requesting more moves from sever");
                    }
                    // If we have not yet advanced to the player on this client, request more moves until we do
                    setTimeout(() => replayMovesFromServer(finalState), SERVER_REQUEST_DELAY);
                }
                else {
                    setTimeout(() => my.playOneMove(finalState), 0);
                }
            }
        }
    }

    /**
     * If a player has closed browser or browser tab, then they should be eliminated.
     */
    function continueIfNextPlayerLeftGame(startState, moves) {
        const nextPlayer = startState.activePlayer();
        if (!nextPlayer) {
            throw new Error("nextPlayer unexpectedly " + nextPlayer +".\n startState=\n" + JSON.stringify(startState));
        }
        const result = startState.getHumanPlayerAfter(nextPlayer);
        //const { nextNextHumanPlayer, numSkippedAIs } = startState.getHumanPlayerAfter(nextPlayer);
        const nextNextHumanPlayer = result.nextNextHumanPlayer;
        const numSkippedAIs = result.numSkippedAIs;

        // We don't want every player to submit to the server because that would result in race conditions.
        // Instead, only submit to server for AI players to play if this will be the next human player.
        if (!moves.length && nextNextHumanPlayer && domUtils.userid() == nextNextHumanPlayer.name) {
            const elapsedTimeSinceRequest = new Date() - requestStartTime;
            console.log(`Waiting for ${nextPlayer.name} for ${elapsedTimeSinceRequest/1000}s. Next human player = ${nextNextHumanPlayer.name}`);
            // If this is true, then we waited too long for some other human player
            const timeout = gameData.humanTimeLimit * 1000 + HUMAN_EXPIRATION_DELAY + numSkippedAIs * AI_TURN_DELAY;
            if (elapsedTimeSinceRequest > timeout) {
                requestStartTime = null;
                console.log("Time limit expired for " + nextPlayer.name + ". They will now be eliminated.");
                const resignationMove = new ResignationMove();
                startState = erisk.makeMove(startState, resignationMove);
                resignationMove.stateId = startState.id;
                resignationMove.gameId = startState.gameId;
                localHumanMoves = [resignationMove];
                console.log(`Persisting move where ${nextPlayer.name} resigned. Current player is now ${startState.activePlayer().name}`);
                persistLocalMovesIfAnyAndPlayAi(startState, false);
            }
        } else {
            requestStartTime = null
        }
    }

    function showEndGame(state) {
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, () => erisk.gameRenderer.updateDisplay(state));
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, function() {
            const winner = state.endResult;
            const delay = 200;
            const duration = 4000;
            if (winner !== CONSTS.DRAWN_GAME) {
                erisk.gameRenderer.showBanner(winner.colorEnd, `${winner.getName()} wins the game!`, delay, duration);
            } else {
                erisk.gameRenderer.showBanner('#333', "The game ends in a draw!", delay, duration);
            }

            erisk.gameRenderer.updateDisplay(state);

            $('turn-count').innerHTML = "Game complete";
            const infoEl = $('info');
            infoEl.innerHTML = domUtils.elem('p', {}, "Click the button below to start a new game.");
            infoEl.style.background = '#555';
            domUtils.hide('move-info');
            erisk.gameRenderer.updateButtons([ {text: "New game"} ]);

            persistLocalMovesIfAnyAndPlayAi(state, true);

            uiCallbacks.setBuildCB(erisk.runSetupScreen);
        });
    }

    return my;
}(erisk || {}));
</script>